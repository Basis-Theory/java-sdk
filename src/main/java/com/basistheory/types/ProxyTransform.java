/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.basistheory.types;

import com.basistheory.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ProxyTransform.Builder.class)
public final class ProxyTransform {
    private final Optional<String> type;

    private final Optional<String> code;

    private final Optional<String> matcher;

    private final Optional<String> expression;

    private final Optional<String> replacement;

    private final Optional<ProxyTransformOptions> options;

    private final Map<String, Object> additionalProperties;

    private ProxyTransform(
            Optional<String> type,
            Optional<String> code,
            Optional<String> matcher,
            Optional<String> expression,
            Optional<String> replacement,
            Optional<ProxyTransformOptions> options,
            Map<String, Object> additionalProperties) {
        this.type = type;
        this.code = code;
        this.matcher = matcher;
        this.expression = expression;
        this.replacement = replacement;
        this.options = options;
        this.additionalProperties = additionalProperties;
    }

    @JsonProperty("type")
    public Optional<String> getType() {
        return type;
    }

    @JsonProperty("code")
    public Optional<String> getCode() {
        return code;
    }

    @JsonProperty("matcher")
    public Optional<String> getMatcher() {
        return matcher;
    }

    @JsonProperty("expression")
    public Optional<String> getExpression() {
        return expression;
    }

    @JsonProperty("replacement")
    public Optional<String> getReplacement() {
        return replacement;
    }

    @JsonProperty("options")
    public Optional<ProxyTransformOptions> getOptions() {
        return options;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ProxyTransform && equalTo((ProxyTransform) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ProxyTransform other) {
        return type.equals(other.type)
                && code.equals(other.code)
                && matcher.equals(other.matcher)
                && expression.equals(other.expression)
                && replacement.equals(other.replacement)
                && options.equals(other.options);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.type, this.code, this.matcher, this.expression, this.replacement, this.options);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> type = Optional.empty();

        private Optional<String> code = Optional.empty();

        private Optional<String> matcher = Optional.empty();

        private Optional<String> expression = Optional.empty();

        private Optional<String> replacement = Optional.empty();

        private Optional<ProxyTransformOptions> options = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ProxyTransform other) {
            type(other.getType());
            code(other.getCode());
            matcher(other.getMatcher());
            expression(other.getExpression());
            replacement(other.getReplacement());
            options(other.getOptions());
            return this;
        }

        @JsonSetter(value = "type", nulls = Nulls.SKIP)
        public Builder type(Optional<String> type) {
            this.type = type;
            return this;
        }

        public Builder type(String type) {
            this.type = Optional.ofNullable(type);
            return this;
        }

        @JsonSetter(value = "code", nulls = Nulls.SKIP)
        public Builder code(Optional<String> code) {
            this.code = code;
            return this;
        }

        public Builder code(String code) {
            this.code = Optional.ofNullable(code);
            return this;
        }

        @JsonSetter(value = "matcher", nulls = Nulls.SKIP)
        public Builder matcher(Optional<String> matcher) {
            this.matcher = matcher;
            return this;
        }

        public Builder matcher(String matcher) {
            this.matcher = Optional.ofNullable(matcher);
            return this;
        }

        @JsonSetter(value = "expression", nulls = Nulls.SKIP)
        public Builder expression(Optional<String> expression) {
            this.expression = expression;
            return this;
        }

        public Builder expression(String expression) {
            this.expression = Optional.ofNullable(expression);
            return this;
        }

        @JsonSetter(value = "replacement", nulls = Nulls.SKIP)
        public Builder replacement(Optional<String> replacement) {
            this.replacement = replacement;
            return this;
        }

        public Builder replacement(String replacement) {
            this.replacement = Optional.ofNullable(replacement);
            return this;
        }

        @JsonSetter(value = "options", nulls = Nulls.SKIP)
        public Builder options(Optional<ProxyTransformOptions> options) {
            this.options = options;
            return this;
        }

        public Builder options(ProxyTransformOptions options) {
            this.options = Optional.ofNullable(options);
            return this;
        }

        public ProxyTransform build() {
            return new ProxyTransform(type, code, matcher, expression, replacement, options, additionalProperties);
        }
    }
}
