/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.basistheory;

import com.basistheory.core.ClientOptions;
import com.basistheory.core.Environment;
import com.basistheory.core.IdempotentRequestOptions;
import com.basistheory.core.ObjectMappers;
import com.basistheory.core.pagination.SyncPagingIterable;
import com.basistheory.errors.NotFoundError;
import com.basistheory.errors.UnprocessableEntityError;
import com.basistheory.resources.applications.ApplicationsClient;
import com.basistheory.resources.applications.requests.CreateApplicationRequest;
import com.basistheory.resources.documents.requests.DocumentsUploadRequest;
import com.basistheory.resources.googlepay.GooglePayClient;
import com.basistheory.resources.googlepay.requests.GooglePayCreateRequest;
import com.basistheory.resources.keys.AsyncKeysClient;
import com.basistheory.resources.proxies.ProxiesClient;
import com.basistheory.resources.proxies.requests.CreateProxyRequest;
import com.basistheory.resources.proxies.requests.PatchProxyRequest;
import com.basistheory.resources.reactors.ReactorsClient;
import com.basistheory.resources.reactors.requests.CreateReactorRequest;
import com.basistheory.resources.reactors.requests.PatchReactorRequest;
import com.basistheory.resources.reactors.requests.ReactRequest;
import com.basistheory.resources.tenants.TenantsClient;
import com.basistheory.resources.tokens.TokensClient;
import com.basistheory.resources.tokens.requests.TokensListV2Request;
import com.basistheory.resources.tokens.requests.UpdateTokenRequest;
import com.basistheory.resources.webhooks.WebhooksClient;
import com.basistheory.resources.webhooks.requests.CreateWebhookRequest;
import com.basistheory.resources.webhooks.requests.UpdateWebhookRequest;
import com.basistheory.types.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.jetbrains.annotations.NotNull;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.assertTrue;

public final class TestClient {
    @Test
    public void shouldCallTenantSelf() {
        TenantsClient client = new TenantsClient(managementClientOptions());
        Tenant actual = client.self().get();
        assertEquals("SDK Integration Tests", actual.getName().get());
    }

    @Test
    public void shouldSupportTokenLifecycle() {
        String cardNumber = "6011000990139424";
        TokensClient tokensClient = new TokensClient(privateClientOptions());

        String tokenId = createToken(tokensClient, cardNumber);
        getAndValidateCardNumber(tokensClient, tokenId, cardNumber);

        // Update currently does not support correct `Content-Type` header for PATCH command
        String updateCardNumber = "4242424242424242";
        updateToken(tokensClient, tokenId, updateCardNumber);
        getAndValidateCardNumber(tokensClient, tokenId, updateCardNumber);

        ApplicationsClient applicationsClient = new ApplicationsClient(managementClientOptions());
        String applicationId = createApplication(applicationsClient);

        // Proxies
        ProxiesClient proxyClient = new ProxiesClient(managementClientOptions());
        Proxy proxy = createProxy(proxyClient, applicationId);
        String proxyId = proxy.getId().get();
        patchProxy(proxyClient, applicationId, proxyId);
        proxyClient.delete(proxyId);

        // Reactors
        ReactorsClient reactorsManagementClient = new ReactorsClient(managementClientOptions());
        Reactor reactor = reactorsManagementClient.create(CreateReactorRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .code("module.exports = function (req) {return {raw: req.args}}")
                .application(Application.builder().id(applicationId).build())
                .build()
        );
        String reactorId = reactor.getId().get();
        reactorsManagementClient.patch(reactorId, PatchReactorRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .code("module.exports = function (req) {return {raw: req.args}}")
                .application(Application.builder().id(applicationId).build())
                .build()
        );
        react(new ReactorsClient(privateClientOptions()), reactorId);
        reactorsManagementClient.delete(reactorId);

        applicationsClient.delete(applicationId);

        tokensClient.delete(tokenId);
        try {
            tokensClient.get(tokenId);
            fail("Should have raised NotFoundError");
        } catch (NotFoundError e) {
            assertTrue(true);
        }
    }

    @Test()
    public void shouldSupportIdempotencyHeaders() {
        TokensClient tokensClient = new TokensClient(privateClientOptions());
        String cardNumber = "6011000990139424";
        String idempotencyKey = UUID.randomUUID().toString();

        String firstTokenId = createToken(
                tokensClient,
                cardNumber,
                IdempotentRequestOptions.builder().idempotencyKey(idempotencyKey).build());

        String secondTokenId = createToken(
                tokensClient,
                cardNumber,
                IdempotentRequestOptions.builder().idempotencyKey(idempotencyKey).build());

        assertEquals(firstTokenId, secondTokenId);
    }

    @Test
    public void shouldSupportPaginationOnListV2() {
        TokensClient tokensClient = new TokensClient(privateClientOptions());
        int pageSize = 3;
        SyncPagingIterable<Token> tokens = tokensClient.listV2(TokensListV2Request.builder()
                .size(pageSize)
                .build());

        int count = 0;
        for (Token token : tokens) {
            count++;
            if (count > pageSize) {
                break;
            }
        }
        assertTrue(count > pageSize);
    }

    @Test
    public void shouldManageWebhookLifecycle() throws InterruptedException {
        WebhooksClient webhooksClient = new WebhooksClient(managementClientOptions());
        String url = "https://fern-test.com/" + UUID.randomUUID();
        String webhookId = createWebhook(webhooksClient, url);
        getAndAssertWebhookUrl(webhooksClient, webhookId, url);

        Thread.sleep(2000); // Required to avoid error `The webhook subscription is undergoing another concurrent operation. Please wait a few seconds, then try again.`

        String updatedUrl = "https://fern-test.com/" + UUID.randomUUID();
        updateWebhook(webhooksClient, webhookId, updatedUrl);
        getAndAssertWebhookUrl(webhooksClient, webhookId, updatedUrl);

        Thread.sleep(2000); // Required to avoid error `The webhook subscription is undergoing another concurrent operation. Please wait a few seconds, then try again.`

        webhooksClient.delete(webhookId);

        // This currently does not work due to webhook sending an empty body in 404;
        // Issue eng-7345
//        ensureWebhookIsRemoved(webhooksClient, webhookId);
    }

     @Test
     public void shouldSupportGooglePay() throws JsonProcessingException {
         GooglePayClient client = new GooglePayClient(privateTestTenantClientOptions());
         GooglePayMethodToken googlePayToken = ObjectMappers.JSON_MAPPER.readValue(
             "{\"signature\":\"MEQCIBnz8wKrUi3qrLSn6KSrTcNIo6YcOzrfre7X49S27MrKAiBMF70q7EHe0Bw8uva77pclggSiPMRTFRFl7TZILyACOQ\\u003d\\u003d\",\"intermediateSigningKey\":{\"signedKey\":\"{\\\"keyValue\\\":\\\"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEnK9rrDl5FJalSwcoZD3qB5EYcA/sYVTH2Nbh6y/EZArFvvBRQA1eI3BIv1iZeCkBLd/A2nU1ve7xENoPOfp7+Q\\\\u003d\\\\u003d\\\",\\\"keyExpiration\\\":\\\"1737724267469\\\"}\",\"signatures\":[\"MEQCIHugFzQtVBVNizwkMhG/POcZAmRRXyeiZpt3aFwBzt5cAiBSOY4pfT4tQGWzZjkldbYkpBwWGpSasxRmlt7XPNOaLQ\\u003d\\u003d\"]},\"protocolVersion\":\"ECv2\",\"signedMessage\":\"{\\\"encryptedMessage\\\":\\\"XURDnvPAIhAKT9rARBV9RT0/yVTesT/w0UniXCJflwu2TkE54UnP7ZmWBo0gKjTJIU3j8D1Rntw2Ywr2UDLbZor+UoeZltzZOAv6iAR4MfvCLSzlh3HcjechwqZM8oxSF2iZoD2XrNqOgaYbOY1EaYoLx1JpftZDuTqSDLYa+szsoPjAUgzBO5TJZTDIa3zDNAdK3UtAPwutL1M4pTyuFhUKOC12J3RzZdaGFANbKSc8vdfqnR1hqsvsEt1sWPf2O3yty91klSA7FDckvwlKfRoNyQMDhaDkEvYUi75uxcjCRHE0Jjbj61bZriSTXiG2KWNF2OKpz7l61kgPJxCpK7A7TV3P4pBLwW7DYbRusO6FupLehxOZl9nBpVfApytCZGjaSXT7QfPpxdBv8j2VfKsodOf/dwv2Thrra9a6ZzFWsUz4l7Jbr4MCBLhXH4lSuxKrlA2Rf/CVPTgz8b88cYpEDZyqLJxDstwy74/Nl7Mjc4V7thzmdskAeYSuZXKXyyeo3BHqkguRkeagEwuHiZoem2V4W2qWOF8hYn14KY3cXXNcVA\\\\u003d\\\\u003d\\\",\\\"ephemeralPublicKey\\\":\\\"BHBDKlM3tik4o9leEkHu+875bHbORaCK7dDeXFCRmv4bzWJw/4bsvtBtaBH3SW5JXkE/6pkRYAtjFzQmHMRQYvc\\\\u003d\\\",\\\"tag\\\":\\\"Hle3Oafx5sfUc3U3sCQgV0tRPhCAvPlVLYiqvbPyTYY\\\\u003d\\\"}\"}",
                 GooglePayMethodToken.class);

         try {
             client.create(GooglePayCreateRequest.builder().googlePaymentData(googlePayToken).build());
             fail("Should have thrown exception");
         } catch (UnprocessableEntityError e) {
             assertTrue(true);
             assertTrue(e.body().getDetail()
                     .orElseThrow(() -> new RuntimeException("No detail in error"))
                     .contains("Failed to decrypt token"), "Expected exception body to contain \"expired intermediateSigningKey\"; Actual: " + e.body().getDetail().get());
         }
     }

    @Test
    public void shouldSupportKeysLifecycle() {
        AsyncKeysClient keysClient = new AsyncKeysClient(managementClientOptions());

        try {
            ClientEncryptionKeyResponse createdKey = keysClient.create().join();
            assertTrue(createdKey.getId().isPresent(), "Key ID should be present");
            String keyId = createdKey.getId().get();
            assertTrue(createdKey.getPublicKeyPem().isPresent(), "Key value should not be null");

            ClientEncryptionKeyMetadataResponse retrievedKey = keysClient.get(keyId).join();
            assertTrue(retrievedKey.getId().isPresent(), "Retrieved key ID should be present");
            assertEquals(keyId, retrievedKey.getId().get(), "Retrieved key ID should match created key ID");
            assertTrue(retrievedKey.getExpiresAt().isPresent(), "Created at timestamp should not be null");

            List<ClientEncryptionKeyMetadataResponse> keys = keysClient.list().join();
            assertTrue(keys.stream().anyMatch(k -> k.getId().get().equals(keyId)), 
                "Created key should be in the list of keys");

            keysClient.delete(keyId).join();

            try {
                keysClient.get(keyId).join();
                fail("Should have raised NotFoundError");
            } catch (Exception e) {
                assertInstanceOf(NotFoundError.class, e.getCause(), "Exception should be NotFoundError");
            }
        } catch (Exception e) {
            fail("Test failed with exception: " + e.getMessage());
        }
    }

    @Test
    public void shouldSupportDocumentsLifecycle() throws IOException {
        BasisTheoryApiClient client = getPrivateApplicationClient();

        // Upload
        File tempFile = Files.createTempFile("test", ".txt").toFile();
        String originalContent = "Hello World";
        try (FileWriter writer = new FileWriter(tempFile)) {
            writer.write(originalContent);
        }
        Map<String, Optional<String>> metadata = new HashMap<>();
        metadata.put("attribute 1", Optional.of("value 1"));
        DocumentsUploadRequest request = DocumentsUploadRequest.builder()
                .request(CreateDocumentRequest.builder()
                        .metadata(metadata).build()).build();
        Document uploaded = client.documents().upload(Optional.of(tempFile), request);

        // GET info
        Document retrieved = client.documents().get(uploaded.getId().get());
        assertEquals(uploaded.getId().get(), retrieved.getId().get());
        assertEquals("text/plain", retrieved.getContentType().get());
        assertEquals("value 1", retrieved.getMetadata().get().get("attribute 1").get());

        // Get data
        InputStream dataStream = client.documents().data().get(uploaded.getId().get());
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int length;
        while ((length = dataStream.read(buffer)) != -1) {
            result.write(buffer, 0, length);
        }
        String actualData = result.toString("UTF-8");
        assertEquals(originalContent, actualData);

        // DELETE
        client.documents().delete(uploaded.getId().get());

        try {
            client.documents().get(uploaded.getId().get());
            fail("Should have raised NotFoundError");
        } catch (NotFoundError e) {
            assertTrue(true);
        }
    }

    @NotNull
    private static BasisTheoryApiClient getPrivateApplicationClient() {
        return new BasisTheoryApiClient(privateClientOptions());
    }

    @NotNull
    private static ClientOptions managementClientOptions() {
        return ClientOptions.builder()
                .environment(Environment.custom(System.getenv("BT_API_URL")))
                .addHeader("BT-API-KEY", System.getenv("BT_MGT_API_KEY"))
                .build();
    }

    @NotNull
    private static ClientOptions privateClientOptions() {
        return ClientOptions.builder()
                .environment(Environment.custom(System.getenv("BT_API_URL")))
                .addHeader("BT-API-KEY", System.getenv("BT_PVT_API_KEY"))
                .build();
    }

    @NotNull
    private static ClientOptions privateTestTenantClientOptions() {
        return ClientOptions.builder()
                .environment(Environment.custom(System.getenv("BT_API_URL")))
                .addHeader("BT-API-KEY", System.getenv("BT_PVT_TEST_API_KEY"))
                .build();
    }

    @NotNull
    private static String createToken(TokensClient tokensClient, String cardNumber) {
        IdempotentRequestOptions requestOptions = IdempotentRequestOptions.builder().build();
        return createToken(tokensClient, cardNumber, requestOptions);
    }

    @NotNull
    private static String createToken(TokensClient tokensClient, String cardNumber, IdempotentRequestOptions requestOptions) {
        Token token = tokensClient.create(CreateTokenRequest.builder()
                .data(new HashMap<String, Object>() {{
                    put("number", cardNumber);
                    put("expiration_month", 4);
                    put("expiration_year", 2025);
                    put("cvc", 123);
                }})
                .type("card")
                .metadata(new HashMap<String, Optional<String>>() {{
                    put("customer_id", Optional.of("3181"));
                }})
                .searchIndexes(Arrays.asList("{{ data.expiration_month }}", "{{ data.number | last4 }}"))
                .fingerprintExpression("{{ data.number }}")
                .mask(new HashMap<String, Object>() {{
                    put("number", "{{ data.number, reveal_last: 4 }}");
                    put("cvc", "{{ data.cvc }}");
                }})
                .deduplicateToken(false)
                .containers(Arrays.asList("/pci/high/"))
                .build(),
                requestOptions);
        String tokenId = token.getId().get();
        assertNotNull(tokenId);
        return tokenId;
    }

    private static void updateToken(TokensClient tokensClient, String tokenId, String updateCardNumber) {
        tokensClient.update(tokenId, UpdateTokenRequest.builder()
                .data(new HashMap<String, Object>() {{
                    put("number", updateCardNumber);
                }})
                .build());
    }

    private static void getAndValidateCardNumber(TokensClient tokensClient, String tokenId, String cardNumber) {
        Token token = tokensClient.get(tokenId);
        assertEquals(cardNumber, ((Map)token.getData().get()).get("number"));
    }

    @NotNull
    private static String createApplication(ApplicationsClient applicationsClient) {
        Application application =  applicationsClient.create(CreateApplicationRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .type("private")
                .permissions(Collections.singletonList("token:use"))
                .build());
        String applicationId = application.getId().get();
        return applicationId;
    }

    private static Proxy createProxy(ProxiesClient proxyClient, String applicationId) {
        Proxy proxy = proxyClient.create(CreateProxyRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .destinationUrl("https://echo.basistheory.com/" + UUID.randomUUID())
                .application(Application.builder().id(applicationId).build())
                .build()
        );
        return proxy;
    }

    private static void patchProxy(ProxiesClient proxyClient, String applicationId, String proxyId) {
        proxyClient.patch(proxyId, PatchProxyRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .destinationUrl("https://echo.basistheory.com/" + UUID.randomUUID())
                .application(Application.builder().id(applicationId).build())
                .build()
        );
    }

    private static void react(ReactorsClient reactorsClient, String reactorId) {
        HashMap<String, Object> expected = new HashMap<String, Object>() {{
            put("Key1", "Key1-" + UUID.randomUUID());
            put("Key2", "Key2-" + UUID.randomUUID());
        }};
        ReactResponse react = reactorsClient.react(reactorId, ReactRequest.builder().args(expected).build());
        assertEquals(expected.get("Key1"), ((Map)react.getRaw().get()).get("Key1"));
        assertEquals(expected.get("Key2"), ((Map)react.getRaw().get()).get("Key2"));
    }

    private static String createWebhook(WebhooksClient webhooksClient, String url) {
        Webhook webhook = webhooksClient.create(CreateWebhookRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .url(url)
                .addEvents("token.created")
                .build()
        );
        String webhookId = webhook.getId();
        return webhookId;
    }

    private static void getAndAssertWebhookUrl(WebhooksClient webhooksClient, String webhookId, String url) {
        Webhook webhook = webhooksClient.get(webhookId);
        assertEquals(url, webhook.getUrl());
    }

    private static void updateWebhook(WebhooksClient webhooksClient, String webhookId, String url) {
        webhooksClient.update(webhookId, UpdateWebhookRequest.builder()
                .name("(Deletable) java-SDK-" + UUID.randomUUID())
                .url(url)
                .addEvents("token.created")
                .addEvents("token.updated")
                .build()
        );
    }

    private static void ensureWebhookIsRemoved(WebhooksClient webhooksClient, String webhookId) {
        try {
            webhooksClient.get(webhookId);
            fail("Should have raised NotFoundError");
        } catch (NotFoundError e) {
            assertTrue(true);
        }
    }

}
